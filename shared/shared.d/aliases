#!/bin/sh
# Cross-platform aliases (works in bash and zsh)

# Modern CLI replacements
command -v bat &>/dev/null && alias cat='bat --paging=never'
command -v zoxide &>/dev/null && eval "$(zoxide init ${SHELL_TYPE:-bash})"

# eza: modern ls replacement with nord-inspired colors
if command -v eza &>/dev/null; then
    # Nord-aligned color scheme for eza
    export EZA_COLORS="\
di=1;34:\
ln=36:\
ex=1;32:\
fi=37:\
*.md=33:\
*.yml=33:\
*.yaml=33:\
*.toml=33:\
*.json=33:\
*.js=33:\
*.ts=33:\
*.py=33:\
*.rs=33:\
*.go=33:\
*.sh=32:\
*.bash=32:\
*.zsh=32:\
*.log=90:\
*.bak=90:\
*.tmp=90:\
*.swp=90:\
*.lock=90:\
*.git=90:\
ur=35:uw=35:ux=35:ue=35:\
gr=34:gw=34:gx=34:\
tr=36:tw=36:tx=36:\
sn=32:sb=32:\
da=36:\
uu=33:gu=33:\
hd=4;37"

    alias ls='eza --icons --group-directories-first'
    alias ll='eza -lgh --icons --git --header --group-directories-first'
    alias la='eza -lagh --icons --git --header --group-directories-first'
    alias l='eza -l --icons --group-directories-first'
    alias lt='eza --tree --icons --level=2 --group-directories-first'
    alias lta='eza --tree --icons --level=3 --group-directories-first -a'
    alias tree='eza --tree --icons --group-directories-first'
else
    alias ll='ls -la'
    alias la='ls -a'
    alias l='ls -l'
fi

# Common aliases
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias grep='grep --color=auto'
alias mkdir='mkdir -pv'
alias df='df -h'
alias du='du -h'

# fzf: fuzzy finder helpers
if command -v fzf &>/dev/null; then
    # fo: fuzzy-open file in editor (with bat preview)
    fo() {
        local file
        file=$(fzf --preview 'bat --color=always --style=numbers --line-range=:500 {} 2>/dev/null || head -500 {}')
        [ -n "$file" ] && ${EDITOR:-nano} "$file"
    }

    # fcd / fj: fuzzy-cd into directory
    fcd() {
        local dir
        if command -v fd &>/dev/null; then
            dir=$(fd --type d --hidden --follow --exclude .git 2>/dev/null | fzf --preview 'eza --tree --icons --level=1 {} 2>/dev/null || ls {}')
        else
            dir=$(find . -type d -not -path '*/\.*' 2>/dev/null | fzf --preview 'eza --tree --icons --level=1 {} 2>/dev/null || ls {}')
        fi
        [ -n "$dir" ] && cd "$dir"
    }
    alias fj='fcd'

    # gb: interactive git branch picker with preview
    gb() {
        local branch target
        branch=$(git branch --all --sort=-committerdate --format='%(refname:short)' 2>/dev/null | \
            grep -v 'HEAD' | \
            fzf --preview 'git log --oneline --graph --color=always -20 {1}' \
                --preview-window=right:50% \
                --header='Select branch (Enter=checkout)')
        [ -z "$branch" ] && return 0
        # Resolve remote refs: origin/foo -> foo (local), remotes/origin/foo -> foo
        target="${branch#remotes/}"
        target="${target#origin/}"
        if git show-ref --verify --quiet "refs/heads/$target"; then
            git checkout "$target"
        else
            git checkout -b "$target" "$branch"
        fi
    }

    # gitlog: interactive commit browser with diff preview
    # Enter = show commit, Alt+Enter = paste hash to command line
    gitlog() {
        local out key hash
        out=$(git log --oneline --graph --color=always --all | \
            fzf --ansi --no-sort --reverse \
                --preview 'echo {} | grep -o "[a-f0-9]\{7,\}" | head -1 | xargs git show --color=always' \
                --preview-window=right:60% \
                --expect=alt-enter \
                --header='Enter=show | Alt+Enter=copy hash')
        key=$(echo "$out" | head -1)
        hash=$(echo "$out" | tail -1 | grep -o '[a-f0-9]\{7,\}' | head -1)
        [ -z "$hash" ] && return
        if [ "$key" = "alt-enter" ]; then
            # Paste hash into command line via readline
            if [ -n "$BASH_VERSION" ]; then
                bind '"\e[0n": "'"$hash"'"'; printf '\e[5n'
            elif [ -n "$ZSH_VERSION" ]; then
                print -z "$hash"
            fi
        else
            git show "$hash"
        fi
    }

    # gitdiff: interactive file diff picker showing changes against HEAD
    # Pick any modified/staged file and see its delta diff
    gitdiff() {
        local file
        file=$(git diff --name-only HEAD | \
            fzf --preview 'git diff --color=always HEAD -- {} 2>/dev/null || echo "No changes"' \
                --preview-window=right:70% \
                --header='Select file to view diff against HEAD (Enter=view | Esc=exit)')
        if [ -n "$file" ]; then
            git diff HEAD -- "$file"
        fi
    }
fi

# navhelp: navigation & fuzzy search cheatsheet
navhelp() {
    cat <<'NAVHELP'
 Navigation & Search Cheatsheet
─────────────────────────────────────────────────

 FUZZY FINDER (fzf)
  fo              open any file in $EDITOR (bat preview)
  fcd / fj        cd into any directory (tree preview)
  fkill           kill process(es) interactively (Tab=multi-select)

 GIT INTERACTIVE (fzf)
  gb              branch picker → checkout on Enter
  gitlog          commit browser (Enter=show | Alt+Enter=copy hash)
  gitdiff         pick modified file → view delta diff vs HEAD

 DIRECTORY JUMPING (zoxide)
  z <query>       jump to a frecent directory
  zi              interactive zoxide picker (fzf)

 BROOT
  br              broot file manager / tree navigator

NAVHELP
}

# Git shortcuts (oh-my-zsh compatible)
alias g='git'

# Status
alias gs='git status'
alias gss='git status --short'
alias gst='git status'

# Add
alias ga='git add'
alias gaa='git add --all'
alias gapa='git add --patch'

# Commit
alias gc='git commit --verbose'
alias gc!='git commit --verbose --amend'
alias gca='git commit --verbose --all'
alias gca!='git commit --verbose --all --amend'
gcam() {
    local branch ticket msg
    branch=$(git branch --show-current 2>/dev/null)
    # Auto-prefix ticket if branch is named like ABC-123 or ABC-123-description.
    # Use sed instead of BASH_REMATCH — works in both bash and zsh.
    ticket=$(echo "$branch" | sed -En 's/^([A-Z]+-[0-9]+).*/\1/p')
    if [[ -n "$ticket" ]]; then
        msg="${ticket}: $*"
    else
        msg="$*"
    fi
    git add -A && git commit -m "$msg"
}
alias gcmsg='git commit --message'
alias gcn!='git commit --verbose --no-edit --amend'

# Branch
alias gbr='git branch'
alias gba='git branch --all'
# gbd: delete branch — fzf picker if no arg given (safe, merged only)
gbd() {
    if [ -n "$1" ]; then
        git branch --delete "$@"
        return
    fi
    local branches
    branches=$(git branch --format='%(refname:short)' | grep -v "^$(git branch --show-current)$" | \
        fzf --multi --preview 'git log --oneline --color=always -10 {}' \
            --preview-window=right:50% \
            --header='gbd: select branches to delete (Tab=multi) — safe, merged only')
    [ -z "$branches" ] && return 0
    echo "$branches" | xargs git branch --delete
}

# gbD: force-delete branch — fzf picker if no arg given
gbD() {
    if [ -n "$1" ]; then
        git branch --delete --force "$@"
        return
    fi
    local branches
    branches=$(git branch --format='%(refname:short)' | grep -v "^$(git branch --show-current)$" | \
        fzf --multi --preview 'git log --oneline --color=always -10 {}' \
            --preview-window=right:50% \
            --header='gbD: select branches to FORCE DELETE (Tab=multi) — unmerged allowed!')
    [ -z "$branches" ] && return 0
    echo "$branches" | xargs git branch --delete --force
}

# Checkout / Switch
alias gco='git checkout'
alias gcb='git checkout -b'
alias go='git checkout origin/$(git rev-parse --abbrev-ref HEAD)'
alias gsw='git switch'
alias gswc='git switch --create'

# Push / Pull / Fetch
alias gp='git push origin $(git branch --show-current)'
alias gpf='git push --force-with-lease origin $(git branch --show-current)'
alias gpf!='git push --force origin $(git branch --show-current)'
alias gpsup='git push --set-upstream origin $(git branch --show-current)'
alias gl='git pull'
alias gf='git fetch'
alias gfo='git fetch origin'

# _git_diff_or_msg: run git diff, show paged output or "no changes" message
_git_diff_or_msg() {
    local label="$1"; shift
    local out
    out=$(git diff "$@" 2>&1)
    if [ -z "$out" ]; then
        echo "  no changes ($label)"
    else
        echo "$out" | ${GIT_PAGER:-${PAGER:-less}}
    fi
}

# _git_stat_colored: run git diff --stat, colorise added/removed counts, page if long
_git_stat_colored() {
    local label="$1"; shift
    local out
    out=$(git diff --stat "$@" 2>&1)
    if [ -z "$out" ]; then
        echo "  no changes ($label)"
        return
    fi
    # Highlight: +N green, -N red, summary line yellow
    local colored
    colored=$(echo "$out" | \
        sed 's/\([0-9][0-9]*\) insertion/\x1b[32m\1 insertion\x1b[0m/g' | \
        sed 's/\([0-9][0-9]*\) deletion/\x1b[31m\1 deletion\x1b[0m/g' | \
        sed 's/+/\x1b[32m+\x1b[0m/g' | \
        sed 's/-/\x1b[31m-\x1b[0m/g')
    # Page only if more than half a screen
    local lines
    lines=$(echo "$out" | wc -l)
    if [ "$lines" -gt 20 ]; then
        echo "$colored" | less -R
    else
        echo "$colored"
    fi
}

# _fzf_pick_commit: fzf commit picker, returns hash
_fzf_pick_commit() {
    git log --oneline --color=always | \
        fzf --ansi --no-sort \
            --preview 'git show --stat --color=always {1}' \
            --header "${1:-Select commit}" | \
        awk '{print $1}'
}

# Diff
gd()    { _git_diff_or_msg "working tree" "$@"; }
gdh()   { _git_diff_or_msg "vs HEAD" HEAD "$@"; }
gdhf()  { _git_stat_colored "vs HEAD" HEAD "$@"; }
gds()   { _git_diff_or_msg "staged" --staged "$@"; }
gdca()  { _git_diff_or_msg "cached" --cached "$@"; }

# gdm: diff current branch vs main (or master)
gdm() {
    local base
    base=$(git rev-parse --verify main 2>/dev/null && echo main || echo master)
    _git_diff_or_msg "vs $base" "$base"...HEAD
}

# gdmf: colored file summary of current branch vs main
gdmf() {
    local base
    base=$(git rev-parse --verify main 2>/dev/null && echo main || echo master)
    _git_stat_colored "vs $base" "$base"...HEAD
}

# gdl: diff vs last commit (HEAD~1) or HEAD~N
gdl() {
    local n="${1:-1}"
    _git_diff_or_msg "vs HEAD~$n" "HEAD~$n"
}

# gdlf: colored file summary vs last commit (HEAD~1) or HEAD~N
gdlf() {
    local n="${1:-1}"
    _git_stat_colored "vs HEAD~$n" "HEAD~$n"
}

# gdc: diff vs a specific commit — fzf picker if no arg given
gdc() {
    local commit="${1:-$(_fzf_pick_commit 'Select commit to diff against')}"
    [ -z "$commit" ] && return 0
    _git_diff_or_msg "vs $commit" "$commit"
}

# gdcf: colored file summary vs a specific commit — fzf picker if no arg given
gdcf() {
    local commit="${1:-$(_fzf_pick_commit 'Select commit for summary')}"
    [ -z "$commit" ] && return 0
    _git_stat_colored "vs $commit" "$commit"
}

# Merge
alias gm='git merge'
alias gma='git merge --abort'

# Rebase
alias grb='git rebase'
alias grbc='git rebase --continue'
alias grba='git rebase --abort'
alias grbs='git rebase --skip'

# gri: interactive rebase (defaults to last 2 commits)
gri() { git rebase -i "HEAD~${1:-2}"; }

# Reset / Restore
alias grh='git reset'
alias grhh='git reset --hard'
alias grs='git restore'
alias grss='git restore --staged'
alias gcl='git clean -fd'

# Stash
alias gsta='git stash push'
alias gstp='git stash pop'
alias gstaa='git stash apply'
alias gstd='git stash drop'
alias gstl='git stash list'

# Log
alias glog='git log --graph --decorate --format="%C(bold blue)%h%C(reset) %C(green)%ad%C(reset) %s%C(auto)%d%C(reset)" --date=format:"%d %b %Y"'
alias gloga='git log --oneline --graph --decorate --all'
alias glg='git log --stat'
alias gsh='git show'

# Cherry-pick
alias gcp='git cherry-pick'
alias gcpa='git cherry-pick --abort'
alias gcpc='git cherry-pick --continue'

# Remote
alias gr='git remote'
alias grv='git remote --verbose'

# Tags
alias gt='git tag'
alias gts='git tag --sign'

# gitgraph: pretty branch graph with colors and dates
alias gitgraph='git log --graph --all --decorate --oneline --color=always --format="%C(bold blue)%h%C(reset) %C(bold green)(%ar)%C(reset) %s %C(dim white)- %an%C(reset)%C(auto)%d%C(reset)"'

# githelp: cheatsheet of all git shortcuts
githelp() {
    cat <<'GITHELP'
 Git Shortcuts Cheatsheet
─────────────────────────────────────────────────

 STATUS / INFO
  gs, gst     git status
  gss         git status --short
  glog        git log (graph + dates)
  gloga       git log --oneline --graph --all
  glg         git log --stat
  gsh         git show
  gitgraph    pretty branch graph

 ADD / COMMIT
  ga <file>   git add
  gaa         git add --all
  gapa        git add --patch
  gc          git commit --verbose
  gc!         git commit --amend
  gca         git commit --all
  gca!        git commit --all --amend
  gcam <msg>  git add -A && commit (auto-prefixes ticket if branch=ABC-123)
  gcmsg <msg> git commit --message
  gcn!        git commit --no-edit --amend

 BRANCH / CHECKOUT
  gbr         git branch
  gba         git branch --all
  gbd [br]    delete branch; fzf picker if no arg (Tab=multi, safe/merged)
  gbD [br]    force-delete branch; fzf picker if no arg (Tab=multi)
  gco <br>    git checkout
  gcb <br>    git checkout -b
  go          git checkout origin/<current> (fetch latest from origin)
  gsw <br>    git switch
  gswc <br>   git switch --create

 PUSH / PULL / FETCH
  gp          git push origin <current> (auto branch name)
  gpf         git push --force-with-lease origin <current>
  gpf!        git push --force origin <current>
  gpsup       git push --set-upstream origin <current>
  gl          git pull
  gf          git fetch
  gfo         git fetch origin

 DIFF
  gd          git diff (working tree)
  gdh         git diff HEAD — unstaged vs last commit (full)
  gdhf        git diff HEAD --stat — files + colored +/- summary
  gds         git diff --staged
  gdca        git diff --cached
  gdm         diff current branch vs main/master (full)
  gdmf        branch vs main — files + colored +/- summary
  gdl [n]     diff vs HEAD~n, default n=1 (full)
  gdlf [n]    diff vs HEAD~n — files + colored +/- summary
  gdc [hash]  diff vs commit; fzf picker if no hash (full)
  gdcf [hash] diff vs commit — files + colored +/- summary

 MERGE / REBASE
  gm          git merge
  gma         git merge --abort
  grb         git rebase
  grbc        git rebase --continue
  grba        git rebase --abort
  grbs        git rebase --skip
  gri [n]     git rebase -i HEAD~n (default: 2)

 RESET / RESTORE
  grh         git reset
  grhh        git reset --hard
  grs         git restore
  grss        git restore --staged
  gcl         git clean -fd

 STASH
  gsta        git stash push
  gstp        git stash pop
  gstaa       git stash apply
  gstd        git stash drop
  gstl        git stash list

 CHERRY-PICK
  gcp         git cherry-pick
  gcpa        git cherry-pick --abort
  gcpc        git cherry-pick --continue

 REMOTE / TAGS
  gr          git remote
  grv         git remote --verbose
  gt          git tag
  gts         git tag --sign

 INTERACTIVE (fzf)
  gb          branch picker (fuzzy) — Enter=checkout
  gbd [br]    branch delete picker — Tab=multi, safe
  gbD [br]    branch force-delete picker — Tab=multi
  gitlog      commit browser — Enter=show, Alt+Enter=copy hash
  gitdiff     file diff picker — view delta diff vs HEAD
  gdc [hash]  commit diff picker — full diff
  gdcf [hash] commit diff picker — files+lines summary
  diff        compare two files with delta
  lg          lazygit
GITHELP
}

# ports: show listening ports
ports() {
    if command -v ss &>/dev/null; then
        ss -tlnp
    elif command -v lsof &>/dev/null; then
        lsof -i -P -n | grep LISTEN
    else
        netstat -tlnp 2>/dev/null
    fi
}

# conns: all established TCP connections with process info
conns() {
    if command -v ss &>/dev/null; then
        ss -tnp state established
    elif command -v lsof &>/dev/null; then
        lsof -i -P -n | grep ESTABLISHED
    else
        netstat -tnp 2>/dev/null | grep ESTABLISHED
    fi
}

# lsport: show which process is using a specific port
lsport() {
    if [ -z "$1" ]; then
        echo "Usage: lsport <port>"
        return 1
    fi
    if command -v ss &>/dev/null; then
        ss -tlnp "sport = :$1" 2>/dev/null
        ss -tlnp "dport = :$1" 2>/dev/null
    fi
    if command -v lsof &>/dev/null; then
        lsof -i ":$1" -P -n
    fi
}

# netwatch: live view of established connections (auto-refresh every 2s)
netwatch() {
    local interval="${1:-2}"
    watch -n "$interval" 'ss -tnp state established 2>/dev/null'
}

# traffic: per-process bandwidth usage (requires nethogs or iftop)
traffic() {
    if command -v nethogs &>/dev/null; then
        sudo nethogs
    elif command -v iftop &>/dev/null; then
        sudo iftop
    else
        echo "No traffic monitor found. Install one:"
        echo "  sudo dnf install nethogs    # per-process bandwidth"
        echo "  sudo dnf install iftop      # per-connection bandwidth"
    fi
}

# localip: show local network interfaces and their IPs
localip() {
    if command -v ip &>/dev/null; then
        ip -br a
    else
        ifconfig 2>/dev/null
    fi
}

# myip: show public IP address
myip() {
    curl -s --max-time 5 https://api.ipify.org && echo
}

# where: show geolocation info for your public IP
where() {
    local data
    data=$(curl -s --max-time 8 "https://ipinfo.io") || { echo "where: request failed"; return 1; }
    if command -v jq &>/dev/null; then
        local ip city region country org tz
        ip=$(echo "$data"      | jq -r '.ip       // "unknown"')
        city=$(echo "$data"    | jq -r '.city     // "unknown"')
        region=$(echo "$data"  | jq -r '.region   // "unknown"')
        country=$(echo "$data" | jq -r '.country  // "unknown"')
        org=$(echo "$data"     | jq -r '.org      // "unknown"')
        tz=$(echo "$data"      | jq -r '.timezone // "unknown"')
        printf "\n Location\n"
        printf "──────────────────────────────────\n"
        printf "  %-10s %s\n" "IP"       "$ip"
        printf "  %-10s %s\n" "City"     "$city"
        printf "  %-10s %s\n" "Region"   "$region"
        printf "  %-10s %s\n" "Country"  "$country"
        printf "  %-10s %s\n" "Org"      "$org"
        printf "  %-10s %s\n" "Timezone" "$tz"
        printf "\n"
    else
        echo "$data"
    fi
}

# nethelp: networking shortcuts cheatsheet
nethelp() {
    cat <<'NETHELP'
 Networking Shortcuts Cheatsheet
─────────────────────────────────────────────────

 PORTS & CONNECTIONS
  ports             listening ports (TCP) with process info
  conns             established TCP connections with process info
  lsport <port>     who is using a specific port
  netwatch [sec]    live-refresh established connections (default: 2s)

 BANDWIDTH / TRAFFIC
  traffic           per-process live bandwidth (nethogs → iftop fallback)
                    requires: sudo dnf install nethogs

 IP / INTERFACES
  localip           local interfaces and their IP addresses
  myip              public (external) IP address
  where             geolocation for your public IP (city, country, ISP, timezone)

 QUICK REFERENCE (manual)
  ss -tlnp          listening TCP ports + process
  ss -tnp           all TCP sockets + process
  ss -s             socket statistics summary
  ss -tnp state established   only active connections
  ip route          routing table
  ip -br a          brief interface + IP list
  nmap -sV host     service version scan (needs nmap)
  curl -I url       check HTTP headers / response

 PROCESS SENDING TRAFFIC?
  traffic           live per-process bandwidth with nethogs
  netwatch          watch connections appear/disappear in real time
  conns             snapshot of who is currently connected
  lsof -i -P -n     all open network files with ports

NETHELP
}

# fkill: fuzzy process killer
if command -v fzf &>/dev/null; then
    fkill() {
        local pid
        pid=$(ps -ef | sed 1d | fzf --multi --header='Select process(es) to kill (Tab=multi-select)' \
            --preview 'echo {}' --preview-window=up:1) || return
        echo "$pid" | awk '{print $2}' | xargs kill "${1:--15}"
    }
fi

# extract: universal archive extractor
extract() {
    if [ -z "$1" ]; then
        echo "Usage: extract <archive> [archive2 ...]"
        echo "Run 'extracthelp' for format guide and cheatsheet"
        return 1
    fi
    for file in "$@"; do
        if [ ! -f "$file" ]; then
            echo "extract: '$file' is not a file"
            continue
        fi
        case "$file" in
            *.tar.bz2|*.tbz2) tar xjf "$file"    ;;
            *.tar.gz|*.tgz)   tar xzf "$file"    ;;
            *.tar.xz|*.txz)   tar xJf "$file"    ;;
            *.tar.zst)        tar --zstd -xf "$file" ;;
            *.tar)            tar xf "$file"     ;;
            *.bz2)            bunzip2 "$file"    ;;
            *.gz)             gunzip "$file"     ;;
            *.xz)             unxz "$file"       ;;
            *.zst)            unzstd "$file"     ;;
            *.zip|*.jar)      unzip "$file"      ;;
            *.rar)            unrar x "$file"    ;;
            *.7z)             7z x "$file"       ;;
            *.Z)              uncompress "$file" ;;
            *.deb)            ar x "$file"       ;;
            *.rpm)            rpm2cpio "$file" | cpio -idmv ;;
            *)                echo "extract: unsupported format '$file'" ;;
        esac
    done
}

# compress: universal archive creator
# Usage: compress <format> <output> <input...>
compress() {
    if [ $# -lt 3 ]; then
        cat <<'USAGE'
Usage: compress <format> <output-name> <file/dir...>

Formats: tar.gz tar.bz2 tar.xz tar.zst zip 7z

Examples:
  compress tar.gz  backup   mydir/
  compress tar.xz  release  src/ README.md
  compress zip     photos   *.jpg
  compress 7z      archive  project/

Output name is without extension (added automatically).
Run 'extracthelp' for full format comparison.
USAGE
        return 1
    fi
    local fmt="$1" out="$2"
    shift 2
    case "$fmt" in
        tar.gz|tgz)    tar czf "${out}.tar.gz" "$@"  ;;
        tar.bz2|tbz2)  tar cjf "${out}.tar.bz2" "$@" ;;
        tar.xz|txz)    tar cJf "${out}.tar.xz" "$@"  ;;
        tar.zst)        tar --zstd -cf "${out}.tar.zst" "$@" ;;
        tar)            tar cf "${out}.tar" "$@"      ;;
        zip)            zip -r "${out}.zip" "$@"      ;;
        7z)             7z a "${out}.7z" "$@"         ;;
        *)              echo "compress: unsupported format '$fmt'"
                        echo "Supported: tar.gz tar.bz2 tar.xz tar.zst zip 7z"
                        return 1 ;;
    esac
}

# extracthelp: archive format cheatsheet
extracthelp() {
    cat <<'EXTRACTHELP'
 Archive & Compression Cheatsheet
─────────────────────────────────────────────────

 QUICK REFERENCE
  extract <file>                    auto-detect and extract any archive
  compress <fmt> <name> <src...>    create archive (fmt: tar.gz tar.xz zip 7z …)

  tar czf out.tar.gz DIR     create .tar.gz
  tar cjf out.tar.bz2 DIR   create .tar.bz2
  tar cJf out.tar.xz DIR    create .tar.xz
  zip -r out.zip DIR         create .zip

 COMPRESSION ONLY (single file)
  Format    Compress           Decompress        Notes
  ──────    ────────           ──────────        ─────
  gzip      gzip file          gunzip file.gz    fast, good ratio, universal
  bzip2     bzip2 file         bunzip2 file.bz2  slower, ~10-20% smaller than gz
  xz        xz file            unxz file.xz      slowest, best ratio
  zstd      zstd file          unzstd file.zst   fast as gz, ratio near xz

  These compress a single file in-place (original is replaced).
  Use flags like gzip -k to keep the original.

 ARCHIVING + COMPRESSION (tar = bundle files, then compress)
  .tar.gz   Most common. Fast, works everywhere.
            tar czf archive.tar.gz dir/
            tar xzf archive.tar.gz

  .tar.bz2  Better compression, 3-5x slower than gz.
            tar cjf archive.tar.bz2 dir/
            tar xjf archive.tar.bz2

  .tar.xz   Best compression, slowest. Great for releases/backups.
            tar cJf archive.tar.xz dir/
            tar xJf archive.tar.xz

  .tar.zst  Modern. Fast as gz, compresses like xz. Needs zstd installed.
            tar --zstd -cf archive.tar.zst dir/
            tar --zstd -xf archive.tar.zst

 OTHER FORMATS
  .zip      Cross-platform (Windows-friendly). No tar needed.
            zip -r archive.zip dir/
            unzip archive.zip

  .7z       Best compression overall, but slow. Needs p7zip.
            7z a archive.7z dir/
            7z x archive.7z

  .rar      Proprietary. Can extract with unrar, but prefer other formats.

 TAR FLAGS EXPLAINED
  c = create    x = extract    t = list contents
  z = gzip      j = bzip2      J = xz
  f = file      v = verbose

  Tip: tar xf auto-detects compression on extract, so
  "tar xf archive.tar.gz" works without the z flag.

 WHEN TO USE WHAT
  Sharing with anyone      → .tar.gz or .zip (universal)
  Sending to Windows       → .zip (native support)
  Backups / releases       → .tar.xz (smallest size)
  Fast local archiving     → .tar.zst (speed + ratio)
  Maximum compression      → .7z (if recipient has 7zip)

 SIZE COMPARISON (typical ~100MB source code)
  .tar        100 MB   (no compression)
  .tar.gz      25 MB   ██████░░░░
  .tar.bz2     22 MB   █████░░░░░
  .tar.xz      18 MB   ████░░░░░░
  .tar.zst     23 MB   █████░░░░░  (default level)
  .7z          17 MB   ████░░░░░░

 SPEED COMPARISON (compress ~100MB)
  gzip        ~2s    ██░░░░░░░░  fastest
  zstd        ~2s    ██░░░░░░░░  fast + better ratio
  bzip2       ~8s    ██████░░░░
  xz         ~30s    █████████░  slowest
  7z         ~35s    ██████████

EXTRACTHELP
}

# shellhelp: everyday shell aliases cheatsheet
shellhelp() {
    cat <<'SHELLHELP'
 Shell Aliases Cheatsheet
─────────────────────────────────────────────────

 LISTING (eza)
  ls              list with icons, dirs first
  l               list (long, no header)
  ll              list long + git status + header
  la              list long + hidden files + git
  lt              tree view (2 levels)
  lta             tree view (3 levels, hidden)
  tree            full tree view

 DIRECTORY
  ..              cd ..
  ...             cd ../..
  ....            cd ../../..
  fcd / fj        fuzzy cd into any directory (fzf)
  z <query>       jump to frecent directory (zoxide)
  zi              interactive zoxide picker

 COMMON
  grep            grep --color=auto
  mkdir           mkdir -pv (create parents, verbose)
  df              df -h (human-readable disk usage)
  du              du -h (human-readable dir sizes)
  cat             bat --paging=never (if bat installed)

 PROCESS
  fkill           fuzzy process killer (Tab=multi-select)

 SAFETY NETS
  rm              rm -i (prompts before delete)
  cp              cp -i (prompts before overwrite)
  mv              mv -i (prompts before overwrite)

 SYSTEM
  e               epicli (shorthand)
  e up            epicli update
  version         show epicli version

SHELLHELP
}

# btophelp: btop keyboard shortcuts and features
btophelp() {
    cat <<'BTOPHELP'
 btop Cheatsheet
─────────────────────────────────────────────────

 NAVIGATION
  Arrow keys / hjkl   move around
  Tab                 next panel
  Enter               select / expand process tree
  Esc                 back / cancel
  q / Ctrl+C          quit

 VIEWS
  1                   CPU view (detailed per-core breakdown)
  2                   memory + swap view
  3                   network view (per-interface traffic)
  4                   disk I/O view
  m                   toggle mini mode (compact overview)
  p                   toggle process list on/off

 PROCESSES
  /  or  f            filter processes by name
  Delete              clear filter
  e                   toggle process tree (parent/child view)
  r                   reverse sort order
  +  /  -             expand / collapse tree branch
  k                   kill process (choose signal interactively)
  t                   terminate process (SIGTERM)
  s                   select sort column
  n                   next sort column

 CPU
  c                   toggle per-core vs aggregate graph
  g                   cycle graph type (braille / block / tty)

 DISPLAY
  F2  or  o           open options / settings
  b                   toggle battery widget (if available)
  Mouse               fully supported — click panels, scroll lists

 TIPS
  Run btop inside tmux for persistent monitoring in a side pane.
  Options are saved to ~/.config/btop/btop.conf — edit themes there.
  Theme files live in ~/.config/btop/themes/ (or /usr/share/btop/themes/).

BTOPHELP
}

# atuinhelp: atuin shell history cheatsheet
atuinhelp() {
    cat <<'ATUINHELP'
 Atuin Cheatsheet
─────────────────────────────────────────────────
 Atuin replaces Ctrl+R with a searchable, syncable shell history database.

 IN THE SHELL
  Ctrl+R              open interactive history search
  Up arrow            also opens atuin search (if configured)

 INTERACTIVE SEARCH
  Type                filter history in real time
  Enter               execute selected command
  Tab                 paste to command line (edit before running)
  Ctrl+D / Delete     remove entry from history
  Alt+1 … Alt+9       jump to entry by position
  Esc                 cancel

 SEARCH FILTERS (prefix your query)
  exit:0              only successful commands
  exit:1              only failed commands
  host:machine        commands from a specific machine
  cwd:/path           commands run in a specific directory
  before:2025-01-01   commands before a date
  after:2024-06-01    commands after a date

  Example: exit:0 git push       successful git pushes only

 CLI COMMANDS
  atuin stats                   most used commands + frequency
  atuin history list            raw history dump
  atuin search <query>          non-interactive search
  atuin import auto             import existing shell history
  atuin sync                    sync history with server

 SETUP (cloud sync — optional)
  atuin register -u <user> -e <email> -p <pass>   create account
  atuin login    -u <user> -p <pass>              login on another machine
  atuin sync                                       pull history from server

  Config file: ~/.config/atuin/config.toml
  Enable:      touch ~/.config/atuin/.enabled

ATUINHELP
}

# shortcutshelp: custom keybindings added by this setup (shell-level only)
shortcutshelp() {
    cat <<'SHORTCUTSHELP'
 Custom Keybindings (added by this setup)
─────────────────────────────────────────────────

 FZF — file & directory navigation
  Ctrl+T          fuzzy file search → inserts path at cursor
  Alt+C           fuzzy cd          → places "cd <dir>" on command line
  Alt+O           fuzzy open file   → Enter=edit in nvim, Alt+Enter=bat preview
  Alt+F           fuzzy files+dirs  → files open in nvim, dirs cd into

  macOS: Option key acts as Alt. Requires iTerm2: Left Option Key = Esc+
         Alt+C → ç   Alt+O → ø   Alt+F → ƒ

 FZF — history & process
  Ctrl+R          fuzzy shell history search (atuin if enabled, fzf otherwise)

 BROOT — file tree
  br              launch broot (interactive tree, cd-on-exit enabled)
  Alt+Enter       cd into selected dir and exit
  :e              open file in $EDITOR
  /               search within tree
  Ctrl+Left/Right collapse / expand directory

 GIT — fzf-powered commands
  gb              branch picker         → Enter=checkout
  gbd             branch delete picker  → Tab=multi, merged-only (safe)
  gbD             branch force-delete   → Tab=multi, unmerged allowed
  gitlog          commit browser        → Enter=show, Alt+Enter=copy hash
  gitdiff         modified-file picker  → Enter=delta diff vs HEAD
  gdc             commit diff picker    → fzf, Enter=full diff
  gdcf            commit diff picker    → fzf, Enter=file+lines summary

 NOTE: run 'keyshelp' for the full keyboard reference (tmux, neovim, shell builtins)

SHORTCUTSHELP
}

# keyshelp: all keyboard shortcuts cheatsheet
keyshelp() {
    cat <<'KEYSHELP'
 Keyboard Shortcuts Cheatsheet
─────────────────────────────────────────────────

 SHELL — fzf (fuzzy finder)
  Ctrl+T          fuzzy file search — inserts selected path at cursor
  Ctrl+R          fuzzy history search — browse and rerun past commands
  Alt+C           fuzzy cd — pick a directory, puts "cd <dir>" on command line
  Alt+O           fuzzy open file — Enter=edit in nvim, Alt+Enter=preview with bat
  Alt+F           fuzzy files+folders combined — files open in nvim, dirs cd into

  macOS: Alt sends Option key. Requires iTerm2: Left Option Key = Esc+
         Alt+C → ç   Alt+O → ø   Alt+F → ƒ

 SHELL — broot
  br              launch broot (interactive file tree)
  Alt+Enter       cd into dir and exit broot
  Ctrl+Left       collapse directory
  Ctrl+Right      expand directory
  /               search in tree
  :e              open file in $EDITOR

 SHELL — general
  Ctrl+A          move cursor to beginning of line
  Ctrl+E          move cursor to end of line
  Ctrl+W          delete word before cursor
  Alt+Backspace   delete word before cursor (zsh)
  Ctrl+U          clear line before cursor
  Ctrl+K          clear line after cursor
  Ctrl+L          clear screen
  Ctrl+Z          suspend process (fg to resume)
  Ctrl+D          exit shell / EOF
  Ctrl+C          cancel current command

 GIT — interactive (fzf)
  gb              branch picker — all branches, preview=log, Enter=checkout
  gitlog          commit browser — preview=diff, Enter=show, Alt+Enter=copy hash
  gitdiff         file diff picker — modified files, Enter=view delta diff
  gdc             commit diff picker — fzf commits, Enter=full diff
  gdcf            commit diff picker — fzf commits, Enter=file summary
  gbd             branch delete picker — Tab=multi-select, safe (merged only)
  gbD             branch force-delete picker — Tab=multi-select

 TMUX (prefix = Ctrl+B)
  prefix + c      new window
  prefix + n/p    next/previous window
  prefix + ,      rename window
  prefix + %      split vertical
  prefix + "      split horizontal
  prefix + arrow  move between panes
  prefix + z      zoom/unzoom pane
  prefix + d      detach session
  prefix + [      scroll mode (q to exit)
  prefix + ?      list all keybindings

 NEOVIM (leader = Space)
  <leader>ff      find files (telescope)
  <leader>fg      live grep
  <C-n>           toggle file tree
  ttt             open terminal
  gd              go to definition
  gr              go to references
  K               hover documentation
  <leader>tg      open lazygit
  <leader>e       show diagnostics
  [d / ]d         previous/next diagnostic

KEYSHELP
}

# utilshelp: list of installed CLI utilities with descriptions
utilshelp() {
    _u() {
        local cmd="$1" name="$2" desc="$3"
        if command -v "$cmd" &>/dev/null; then
            printf "  %-16s %s\n" "$name" "$desc"
        else
            printf "  %-16s %s\n" "$name" "$desc  [not installed]"
        fi
    }

    cat <<'HDR'
 CLI Utilities
─────────────────────────────────────────────────

 CORE
HDR
    _u bat      "bat"      "cat with syntax highlighting and line numbers"
    _u eza      "eza"      "modern ls — icons, git status, colors"
    _u fd       "fd"       "fast and friendly find alternative"
    _u fzf      "fzf"      "fuzzy finder — interactive filter for anything"
    _u rg       "rg"       "ripgrep — blazing fast recursive grep"
    _u jq       "jq"       "JSON processor and pretty-printer"
    _u zoxide   "zoxide"   "smarter cd — jumps to frecent directories (z, zi)"
    _u mc       "mc"       "Midnight Commander — visual file manager"
    _u tree     "tree"     "directory tree viewer"
    _u tldr     "tldr"     "practical examples for any command (tldr tar, tldr git)"
    echo ""
    echo " SHELL"
    _u starship "starship" "cross-shell prompt with git/language context"
    _u atuin    "atuin"    "shell history sync across machines (Ctrl+R)"
    _u tmux     "tmux"     "terminal multiplexer — panes, windows, sessions"
    echo ""
    echo " GIT"
    _u lazygit  "lg"       "full git TUI — branches, diffs, stash, rebase"
    _u delta    "delta"    "better diff viewer — syntax highlighting, side-by-side"
    _u gh       "gh"       "GitHub CLI — PRs, issues, releases from terminal"
    echo ""
    echo " MONITORING"
    _u htop     "htop"     "interactive process viewer"
    _u btop     "btop"     "modern resource monitor — CPU, mem, net, disk"
    _u nethogs  "nethogs"  "per-process network bandwidth (sudo)"
    _u iftop    "iftop"    "per-connection network bandwidth (sudo)"
    echo ""
    echo " EDITORS"
    _u nvim     "nvim"     "Neovim — extensible modal editor"
    echo ""
    echo " MEDIA & OTHER"
    _u ffmpeg   "ffmpeg"   "media converter and stream processor"
    _u curl     "curl"     "HTTP client — requests, downloads, API calls"
    _u wget     "wget"     "HTTP/FTP downloader"
    echo ""
}

# info: interactive cheatsheet navigator (requires fzf)
#   info            open navigator
#   info --rebuild  regenerate all cheatsheet files
info() {
    local helpdir="${XDG_DATA_HOME:-$HOME/.local/share}/epicli/help"

    _info_topics=(atuin archive btop git keybindings navigation networking shell shortcuts utilities)

    _info_build() {
        mkdir -p "$helpdir"
        atuinhelp       > "$helpdir/atuin"
        extracthelp     > "$helpdir/archive"
        btophelp        > "$helpdir/btop"
        githelp         > "$helpdir/git"
        keyshelp        > "$helpdir/keybindings"
        navhelp         > "$helpdir/navigation"
        nethelp         > "$helpdir/networking"
        shellhelp       > "$helpdir/shell"
        shortcutshelp   > "$helpdir/shortcuts"
        utilshelp       > "$helpdir/utilities"
        echo "info: cheatsheets written to $helpdir"
    }

    if [ "$1" = "--rebuild" ]; then
        _info_build
        return 0
    fi

    if ! command -v fzf &>/dev/null; then
        echo "info: fzf is required"
        return 1
    fi

    # Build on first use, or rebuild if any topic file is missing
    local _topic _needs_build=0
    if [ ! -d "$helpdir" ]; then
        _needs_build=1
    else
        for _topic in "${_info_topics[@]}"; do
            [ -f "$helpdir/$_topic" ] || { _needs_build=1; break; }
        done
    fi
    [ "$_needs_build" = "1" ] && _info_build

    local selected
    selected=$(ls "$helpdir" | sort | \
        fzf --prompt='  Topic: ' \
            --preview="cat $helpdir/{}" \
            --preview-window='right:65%:wrap' \
            --border=rounded \
            --info=hidden \
            --header=$'\n  Cheatsheets — Enter to open, Esc to quit\n' \
            --height=100%)

    [ -z "$selected" ] && return 0

    if command -v bat &>/dev/null; then
        bat --paging=always --style=plain --color=always "$helpdir/$selected" | less -R
    else
        less "$helpdir/$selected"
    fi
}

# epicli shortcuts
alias e='epicli'
alias version='epicli version'

# Safety nets
alias rm='rm -i'
alias cp='cp -i'
alias mv='mv -i'
